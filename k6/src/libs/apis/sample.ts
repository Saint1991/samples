/**
 * typebook
 * Schema Registry for Avro with MySQL backend
 *
 * The version of the OpenAPI document: 0.4.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
import { check } from 'k6';
import http, { RefinedParams, RefinedResponse, RequestBody, ResponseType } from 'k6/http';


import { ErrorResponse } from '../model/errorResponse';
import { ObjectId } from '../model/objectId';
import { Schema } from '../model/schema';
import { SchemaCompatibility } from '../model/schemaCompatibility';


export class SchemaApi {

  constructor(protected readonly baseUrl: string) { }

  protected request<T extends ResponseType | undefined>(method: string, url: string, body?: RequestBody | null, params?: RefinedParams<T>): RefinedResponse<T> {
    return http.request(method, url, body, params);
  }

  /**
   * Check if a posted schema is compatible with the specific version of schema under the specified subject
   * @param subject Subject Name
   * @param version schema version
   * @param body 
   */
  checkSchemaCompatibility(subject: string, version: string, body: object, params?: RefinedParams<'text'>): RefinedResponse<'text'> {
    const url = `${this.baseUrl}/compatibility/subjects/${subject}/versions/${version}`;
    let queryParams = '';
    

    const contentType = 'application/json' as string;
    const headers = { 'Content-Type': contentType, 'Accept': 'application/json' };
    const mergedParams = { ...params, headers: { ...params?.headers, ...headers } };

    let payload = null;
    if (contentType === 'application/json' && typeof body === 'object' && body != null) {
      payload = JSON.stringify(body);
    } else {
      payload = body?.toString();
    }
    const response = this.request<'text'>('POST', `${url}${queryParams}`, payload, mergedParams);
    
    check(response, {
      'verifying result': res => res.status === 200
    });
    return response;
  }

  /**
   * Retrieve a schema with the specified id
   * @param id Schema ID
   */
  getSchemaById(id: number, params?: RefinedParams<'text'>): RefinedResponse<'text'> {
    const url = `${this.baseUrl}/schemas/ids/${id}`;
    let queryParams = '';
    

    
    const headers = { 'Accept': 'application/json' };
    const mergedParams = { ...params, headers: { ...params?.headers, ...headers } };

    let payload = null;
    const response = this.request<'text'>('GET', `${url}${queryParams}`, payload, mergedParams);
    
    check(response, {
      'schema definition': res => res.status === 200
    });
    return response;
  }

  /**
   * Read a specific version of schema definition under the specified subject
   * Read a specific version of schema definition under the specified subject. The variable for version can take on one of the following format \&quot;latest\&quot;, \&quot;v1\&quot;, or \&quot;v1.0.0\&quot;, with the latter two representing the major version and the semantic version respectively. 
   * @param subject Subject Name
   * @param version semantic version string like \&quot;v1\&quot;, \&quot;v1.3.1\&quot; or \&quot;latest\&quot;
   */
  getSchemaByVersion(subject: string, version: string, params?: RefinedParams<'text'>): RefinedResponse<'text'> {
    const url = `${this.baseUrl}/subjects/${subject}/versions/${version}`;
    let queryParams = '';
    

    
    const headers = { 'Accept': 'application/json' };
    const mergedParams = { ...params, headers: { ...params?.headers, ...headers } };

    let payload = null;
    const response = this.request<'text'>('GET', `${url}${queryParams}`, payload, mergedParams);
    
    check(response, {
      'schema definition': res => res.status === 200
    });
    return response;
  }

  /**
   * Read registered versions under the specified subject
   * @param subject Subject Name
   */
  getSchemaVersions(subject: string, params?: RefinedParams<'text'>): RefinedResponse<'text'> {
    const url = `${this.baseUrl}/subjects/${subject}/versions`;
    let queryParams = '';
    

    
    const headers = { 'Accept': 'application/json' };
    const mergedParams = { ...params, headers: { ...params?.headers, ...headers } };

    let payload = null;
    const response = this.request<'text'>('GET', `${url}${queryParams}`, payload, mergedParams);
    
    check(response, {
      'the registered versions': res => res.status === 200
    });
    return response;
  }

  /**
   * Check if the posted schema is already exists under the specified subject
   * @param subject Subject Name
   * @param body 
   */
  lookupAllSchemasByDefinition(subject: string, body: object, params?: RefinedParams<'text'>): RefinedResponse<'text'> {
    const url = `${this.baseUrl}/subjects/${subject}/schema/lookupAll`;
    let queryParams = '';
    

    const contentType = 'application/json' as string;
    const headers = { 'Content-Type': contentType, 'Accept': 'application/json' };
    const mergedParams = { ...params, headers: { ...params?.headers, ...headers } };

    let payload = null;
    if (contentType === 'application/json' && typeof body === 'object' && body != null) {
      payload = JSON.stringify(body);
    } else {
      payload = body?.toString();
    }
    const response = this.request<'text'>('POST', `${url}${queryParams}`, payload, mergedParams);
    
    check(response, {
      'a list of schemas': res => res.status === 200
    });
    return response;
  }

  /**
   * Get the latest schema information which has the same schema definition as the posted schema.
   * @param subject Subject Name
   * @param body 
   */
  lookupSchemaByDefinition(subject: string, body: File, params?: RefinedParams<'text'>): RefinedResponse<'text'> {
    const url = `${this.baseUrl}/subjects/${subject}/schema/lookup`;
    let queryParams = '';
    

    const contentType = 'application/octet-stream' as string;
    const headers = { 'Content-Type': contentType, 'Accept': 'application/json' };
    const mergedParams = { ...params, headers: { ...params?.headers, ...headers } };

    let payload = null;
    if (contentType === 'application/json' && typeof body === 'object' && body != null) {
      payload = JSON.stringify(body);
    } else {
      payload = body?.toString();
    }
    const response = this.request<'text'>('POST', `${url}${queryParams}`, payload, mergedParams);
    
    check(response, {
      'If the posted schema has already existed, return the latest schema information.': res => res.status === 200
    });
    return response;
  }

  /**
   * Register a new schema under the given subject
   * @param subject Subject Name
   * @param body 
   */
  registerSchema(subject: string, body: object, params?: RefinedParams<'text'>): RefinedResponse<'text'> {
    const url = `${this.baseUrl}/subjects/${subject}/versions`;
    let queryParams = '';
    

    const contentType = 'application/json' as string;
    const headers = { 'Content-Type': contentType, 'Accept': 'application/json' };
    const mergedParams = { ...params, headers: { ...params?.headers, ...headers } };

    let payload = null;
    if (contentType === 'application/json' && typeof body === 'object' && body != null) {
      payload = JSON.stringify(body);
    } else {
      payload = body?.toString();
    }
    const response = this.request<'text'>('POST', `${url}${queryParams}`, payload, mergedParams);
    
    check(response, {
      'ID for the posted schema when it is the same as the latest schema.': res => res.status === 200
    });
    check(response, {
      'ID for the registered schema': res => res.status === 201
    });
    return response;
  }

}

